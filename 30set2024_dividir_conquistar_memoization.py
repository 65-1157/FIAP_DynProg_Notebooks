# -*- coding: utf-8 -*-
"""30set2024_dividir_conquistar_memoization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zSX_cnr9L3HTPZ_3XZTllM-D2NuxTKir

#### Este notebook versa sobre Dividir Conquistar & Memoization para soma maxima em array
"""

# import libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import time
import psutil
import os

"""#### Parametros tecnicos"""

NM = 250 # quantidade maxima de elementos no array

# função para soma maxima com memoisation
def max_sum_memo(arr):
  # array = input
    memo = {} # estrutura de apoio - dicionário

    def memos(i): # funcao de memoisation
        if i == 0:
            return arr[0]
        if i in memo: # confere se o resultado já existe
            return memo[i]

        # Recursive case: max sum ending at i is either arr[i] itself or arr[i] + max sum ending at i-1
        memo[i] = max(arr[i], arr[i] + memos(i - 1))
        return memo[i]

    return max(memos(i) for i in range(len(arr)))

"""#### Teste simples"""

# Example usage
arr = [-2, 1, -15, 4, -1, 2, 1, -5, 4]
print("Soma_max_memoisation:", max_sum_memo(arr))

"""#### Exploracao dificuldade computacional"""

dificult = pd.DataFrame() # dataframe auxiliar
tempo = pd.Series(dtype='float64')  # estrutura de dados auxiliar
tamanho = pd.Series(dtype='int64')  # estrutura de dados auxiliar
memoria = pd.Series(dtype='float64')  # estrutura de dados auxiliar
for n in range (4,NM): # comecar com array de 4 elementos no minimo e no maximo NN
  array = np.random.randint(-20,20,n) # geracao de array aleatorio
  start = time.time()
  proc = psutil.Process(os.getpid())
  start_memory = proc.memory_info().rss
  result = max_sum_memo(array)
  stop = time.time()
  end_memory = proc.memory_info().rss
  sprint = stop - start
  memo_used = (end_memory - start_memory)
  sprint = (round(sprint,6)) *1000
  tamanho = np.append(tamanho,n)
  tempo = np.append(tempo,sprint)
  memoria = np.append(memoria,memo_used)
dificult['tamanho'] = tamanho
dificult['Tempo_execucao'] = tempo
dificult['Memoria_usada'] = memoria

plt.figure(figsize=(10,4)) # definição do tamanho da figura
plt.style.use('fivethirtyeight') # estilo de impressao = melhorar visualizacao
sns.scatterplot(data = dificult, x = 'tamanho', y = 'Tempo_execucao', color = 'blue') # grafico com os pontos
plt.xlabel('numero de elementos no array')
plt.ylabel('Tempo de execução - milisegundos', fontsize = 10)
plt.title('Dividir/Conquistar tamanho array x tempo_exec', fontsize = 20)
plt.grid(True)
plt.show()

plt.figure(figsize=(10,2)) # definição do tamanho da figura
plt.style.use('fivethirtyeight') # estilo de impressao = melhorar visualizacao
sns.scatterplot(data = dificult, x = 'tamanho', y = 'Memoria_usada', color = 'green') # grafico com os pontos
plt.xlabel('numero de elementos no array')
plt.ylabel('Memoria_usada em B', fontsize = 10)
plt.title('Dividir/Conquistar tamanho_array x memoria_usada')
plt.grid(True)
plt.show()

